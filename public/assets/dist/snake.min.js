

var Game = {

    preload : function() {
        // Here we load all the needed resources for the level.
        // In our case, that's just two squares - one for the snake body and one for the apple.
        game.load.image('snake1', './assets/images/snake1.png');
        game.load.image('apple', './assets/images/apple.png');
        game.load.image('orange', './assets/images/orange.png');
        game.load.image('banana', './assets/images/banana.png');
        game.load.spritesheet('boom', 'assets/images/boom.png', 15, 15,7);
    },
    create : function() {
        squareSize = 15;                // The length of a side of the squares. Our image is 15x15 pixels.
        countover = 10;
        speed = 0;                      // Game speed.
        updateDelay = 0;                // A variable for control over update rates.
        textStyle_Key = { font: "bold 14px sans-serif", fill: "#46c0f9", align: "center" };
        textStyle_Value = { font: "bold 18px sans-serif", fill: "#fff", align: "center" };
        snake1= new Snake('Player 1','snake1',1);
        snake1.generateScore(textStyle_Key, textStyle_Value, 30, 20);
        apple= new Fruit('apple',3);
        orange= new Fruit('orange',2);
        banana= new Fruit('banana',1);
        cursors = game.input.keyboard.createCursorKeys();
        snakes = [snake1];




        game.stage.backgroundColor = '#061f27';
        // Speed.

        game.add.text(500, 20, "SPEED", textStyle_Key);
        speedTextValue = game.add.text(558, 18, speed.toString(), textStyle_Value);



    },
    update: function() {

        //----------------------------------controls

        if (cursors.right.isDown && snake1.direction!='left')
        {
            snake1.newdirection = 'right';
        }
        else if (cursors.left.isDown && snake1.direction!='right')
        {
            snake1.newdirection = 'left';
        }
        else if (cursors.up.isDown && snake1.direction!='down')
        {
            snake1.newdirection = 'up';
        }
        else if (cursors.down.isDown && snake1.direction!='up')
        {
            snake1.newdirection = 'down';
        }


        // A formula to calculate game speed based on the score.
        // The higher the score, the higher the game speed, with a maximum of 10;
        speed = Math.min(10, Math.floor(snake1.score/5));

        // Update speed value on game screen.
        speedTextValue.text = '' + speed;

        // Since the update function of Phaser has an update rate of around 60 FPS,
        // we need to slow that down make the game playable.

        // Increase a counter on every update call.
        updateDelay++;

        // Do game stuff only if the counter is aliquot to (10 - the game speed).
        // The higher the speed, the more frequently this is fulfilled,
        // making the snake move faster.
        if (updateDelay % (10 - speed) == 0) {
            snake1.move();
            snake1.grow();

            // Check for apple collision.
            fruitCollision(snake1, apple);
            fruitCollision(snake1, orange);
            fruitCollision(snake1, banana);

            // Check for collision with self. Parameter is the head of the snake.
            snakeCollision(snake1, snake1);

            //// Check with collision with wall. Parameter is the head of the snake.
            wallCollision(snake1);
            //game.state.start('Game_Over');
            if (!snake1.alive ) {
                countover--;
                if(countover==0)
                {
                    game.state.start('Game_Over',true,true,snakes);
                }
            }
        }
    }
};


var Game2 = {

    preload : function() {
        // Here we load all the needed resources for the level.
        // In our case, that's just two squares - one for the snake body and one for the apple.
        game.load.image('snake1', './assets/images/snake1.png');
        game.load.image('snake2', './assets/images/snake2.png');
        game.load.image('apple', './assets/images/apple.png');
        game.load.image('orange', './assets/images/orange.png');
        game.load.image('banana', './assets/images/banana.png');
        game.load.spritesheet('boom', 'assets/images/boom.png', 15, 15,7);
    },
    create : function() {
        squareSize = 15;                // The length of a side of the squares. Our image is 15x15 pixels.
        speed = 0;                      // Game speed.
        updateDelay = 0;                // A variable for control over update rates.
        countover = 20;
        textStyle_Key = { font: "bold 14px sans-serif", fill: "#46c0f9", align: "center" };
        textStyle_Value = { font: "bold 18px sans-serif", fill: "#fff", align: "center" };
        snake1= new Snake('Player 1','snake1',1);
        snake2= new Snake('Player 2','snake2',4);
        snake1.generateScore(textStyle_Key, textStyle_Value, 10, 10);
        snake2.generateScore(textStyle_Key, textStyle_Value, 10, 25);
        apple= new Fruit('apple',3);
        orange= new Fruit('orange',2);
        banana= new Fruit('banana',1);
        snakes = [snake1,snake2];

        cursors = game.input.keyboard.createCursorKeys();
        //-------------------------------for second player
        player2up = game.input.keyboard.addKey(Phaser.Keyboard.W);
        player2down = game.input.keyboard.addKey(Phaser.Keyboard.S);
        player2left = game.input.keyboard.addKey(Phaser.Keyboard.A);
        player2right = game.input.keyboard.addKey(Phaser.Keyboard.D);


        game.stage.backgroundColor = '#061f27';
        // Speed.

        game.add.text(500, 20, "SPEED", textStyle_Key);
        speedTextValue = game.add.text(558, 18, speed.toString(), textStyle_Value);

    },
    update: function() {

        //----------------------------------controls

        if (cursors.right.isDown && snake1.direction!='left')
        {
            snake1.newdirection = 'right';
        }
        else if (cursors.left.isDown && snake1.direction!='right')
        {
            snake1.newdirection = 'left';
        }
        else if (cursors.up.isDown && snake1.direction!='down')
        {
            snake1.newdirection = 'up';
        }
        else if (cursors.down.isDown && snake1.direction!='up')
        {
            snake1.newdirection = 'down';
        }




        if (player2right.isDown &&  snake2.direction !='left')
        {
            snake2.newdirection = 'right';
        }
        else if (player2left.isDown && snake2.direction!='right')
        {
            snake2.newdirection = 'left';
        }
        else if (player2up.isDown && snake2.direction!='down')
        {
            snake2.newdirection = 'up';
        }
        else if (player2down.isDown && snake2.direction!='up')
        {
            snake2.newdirection = 'down';
        }


        // A formula to calculate game speed based on the score.
        // The higher the score, the higher the game speed, with a maximum of 10;
        speed = Math.min(10, Math.floor((snake1.score + snake2.score)/5));

        // Update speed value on game screen.
        speedTextValue.text = '' + speed;

        // Since the update function of Phaser has an update rate of around 60 FPS,
        // we need to slow that down make the game playable.

        // Increase a counter on every update call.
        updateDelay++;

        // Do game stuff only if the counter is aliquot to (10 - the game speed).
        // The higher the speed, the more frequently this is fulfilled,
        // making the snake move faster.
        if (updateDelay % (10 - speed) == 0) {
            snake1.move();
            snake1.grow();
            snake2.move();
            snake2.grow();

            // Check for apple collision.
            fruitCollision(snake1,apple);
            fruitCollision(snake1,orange);
            fruitCollision(snake1,banana);

            fruitCollision(snake2,apple);
            fruitCollision(snake2,orange);
            fruitCollision(snake2,banana);

            // Check for collision with self. Parameter is the head of the snake.
            snakeCollision(snake1,snake1);
            snakeCollision(snake1,snake2);
            snakeCollision(snake2,snake2);
            snakeCollision(snake2,snake1);

            //// Check with collision with wall. Parameter is the head of the snake.
            wallCollision(snake1);
            wallCollision(snake2);

            if (!snake1.alive || !snake2.alive) {
                countover--;
                if(countover==0)
                {
                    game.state.start('Game_Over',true,true,snakes);
                }
            }

        }

    }



};
var socket = new WebSocket("ws://127.0.0.1:2000");
var open=false;
socket.onopen=function()
{
    open = true;
}
socket.onmessage=function(evt)
{
    var data = JSON.parse(evt.data);
    alert(data.snake);
}
socket.onclose=function()
{
    open = false;
}


var Gamem = {

    preload : function() {
        // Here we load all the needed resources for the level.
        // In our case, that's just two squares - one for the snake body and one for the apple.
        game.load.image('snake1', './assets/images/snake1.png');
        game.load.image('snake2', './assets/images/snake2.png');
        game.load.image('snake3', './assets/images/snake3.png');
        game.load.image('snake4', './assets/images/snake4.png');
        game.load.image('snake5', './assets/images/snake5.png');
        game.load.image('snake6', './assets/images/snake6.png');
        game.load.image('snake7', './assets/images/snake7.png');
        game.load.image('snake8', './assets/images/snake8.png');
        game.load.image('apple', './assets/images/apple.png');
        game.load.image('orange', './assets/images/orange.png');
        game.load.image('banana', './assets/images/banana.png');
        game.load.spritesheet('boom', 'assets/images/boom.png', 15, 15,7);
    },
    create : function() {
        squareSize = 15;                // The length of a side of the squares. Our image is 15x15 pixels.
        speed = 0;                      // Game speed.
        updateDelay = 0;                // A variable for control over update rates.
        numberplayers=8;
        player=1;                       // The player that you control
        countover = 20;
        textStyle_Key = { font: "bold 14px sans-serif", fill: "#46c0f9", align: "center" };
        textStyle_Value = { font: "bold 18px sans-serif", fill: "#fff", align: "center" };
        snakes = [];
        scorespace=10;

        for(var i=0; i<numberplayers;i++)
        {
            snakes[i]= new Snake('Player '+ (i+1),'snake'+(i+1),(i+1));
            //snakes[i].generateScore(textStyle_Key, textStyle_Value, 10, scorespace);
            scorespace=scorespace+15;
        }
        apple= new Fruit('apple',3);
        orange= new Fruit('orange',2);
        banana= new Fruit('banana',1);


        cursors = game.input.keyboard.createCursorKeys();

        game.stage.backgroundColor = '#061f27';
        // Speed.

        game.add.text(500, 20, "SPEED", textStyle_Key);
        speedTextValue = game.add.text(558, 18, speed.toString(), textStyle_Value);

        player--;

    },
    update: function() {

        //----------------------------------controls

        if (cursors.right.isDown && snakes[player].direction!='left' && snakes[player].direction!='right')
        {
            snakes[player].newdirection = 'right';
            this.sendsocket('right');
        }
        else if (cursors.left.isDown && snakes[player].direction!='right' && snakes[player].direction!='left')
        {
            snakes[player].newdirection = 'left';
            this.sendsocket('left');
        }
        else if (cursors.up.isDown && snakes[player].direction!='down' && snakes[player].direction!='up')
        {
            snakes[player].newdirection = 'up';
            this.sendsocket('up');
        }
        else if (cursors.down.isDown && snakes[player].direction!='up' && snakes[player].direction!='down')
        {
            snakes[player].newdirection = 'down';
            this.sendsocket('down');
        }

        // A formula to calculate game speed based on the score.
        // The higher the score, the higher the game speed, with a maximum of 10;
        speed = Math.min(10, Math.floor(snakes[0].score/5));

        // Update speed value on game screen.
        speedTextValue.text = '' + speed;

        // Since the update function of Phaser has an update rate of around 60 FPS,
        // we need to slow that down make the game playable.

        // Increase a counter on every update call.
        updateDelay++;

        // Do game stuff only if the counter is aliquot to (10 - the game speed).
        // The higher the speed, the more frequently this is fulfilled,
        // making the snake move faster.
        if (updateDelay % (10 - speed) == 0) {
            var survivors = 0;
            for(var i=0; i<numberplayers;i++)
            {
                snakes[i].move();
                snakes[i].grow();
                fruitCollision(snakes[i],apple);
                fruitCollision(snakes[i],orange);
                fruitCollision(snakes[i],banana);
                wallCollision(snakes[i]);
                for(var j=0; j<numberplayers;j++) {
                    snakeCollision(snakes[i],snakes[j]);
                }
                if (snakes[i].alive) survivors++;
            }
            if(survivors<2)
            {
                countover--;
                if(countover==0)
                {
                    game.state.start('Game_Over',true,true,snakes);
                }
            }
        }

    },
    sendsocket: function(direction)
    {
        socket.send(JSON.stringify({
            snake:player,
            newdirection: direction
        }));
    }



};
var Game_Over = {

    preload : function() {
        // Load the needed image for this game screen.
        game.load.image('gameover', './assets/images/gameover.png');
    },

    create : function() {

        var first = {};
        var second = {};
        var third = {};
        var maxscore=0;
        var secondmaxscore=0;
        var thirdmaxscore=0;
        for (var i = 0; i < snakes.length; i++) {
            if(!snakes[i].alive)
            {
                if(snakes[i].score>=maxscore)
                {
                    third=second;
                    second=first;
                    first = snakes[i];
                    maxscore=snakes[i].score;
                }

                else if(snakes[i].score>=secondmaxscore)
                {
                    third=second;
                    second = snakes[i];
                    secondmaxscore=snakes[i].score;
                }
                else if(snakes[i].score>=thirdmaxscore)
                {
                    third= snakes[i];
                    thirdmaxscore=snakes[i].score;
                }

            }

        }
        maxscore=0;
        secondmaxscore=0;
        thirdmaxscore=0;
        for (var i = 0; i < snakes.length; i++) {
            if(snakes[i].alive)
            {

                if(snakes[i].score>=maxscore)
                {
                    third=second;
                    second=first;
                    first = snakes[i];
                    maxscore=snakes[i].score;
                }

                else if(snakes[i].score>=secondmaxscore)
                {
                    third=second;
                    second = snakes[i];
                    secondmaxscore=snakes[i].score;
                }
                else if(snakes[i].score>=thirdmaxscore)
                {
                    third= snakes[i];
                    thirdmaxscore=snakes[i].score;
                }
            }

        }
        // Create button to start game like in Menu.
        this.add.button(0, 0, 'gameover', this.startGame, this);


        game.add.text(235, 310, first.name+': ', { font: "bold 16px sans-serif", fill: "#46c0f9", align: "center"});
        game.add.text(350, 308, first.score.toString() + ' Winner!!', { font: "bold 20px sans-serif", fill: "#fff", align: "center" });
        if(!isEmpty(second))
        {
            game.add.text(235, 330, second.name+': ', { font: "bold 16px sans-serif", fill: "#46c0f9", align: "center"});
            game.add.text(350, 328, second.score.toString(), { font: "bold 20px sans-serif", fill: "#fff", align: "center" });
        }
        if(!isEmpty(third))
        {
            game.add.text(235, 350, third.name+': ', { font: "bold 16px sans-serif", fill: "#46c0f9", align: "center"});
            game.add.text(350, 348, third.score.toString(), { font: "bold 20px sans-serif", fill: "#fff", align: "center" });
        }
    },

    startGame: function () {
        // Change the state back to Game.
        if(gameMode==1) this.state.start('Game');
        if(gameMode==2) this.state.start('Game2');
        if(gameMode==3) this.state.start('Gamem');

    }
};
var game,squareSize, speed,updateDelay,cursors, speedTextValue;
var gameMode=3;

var Menu = {
    preload: function()
    {
        game.load.image('menu','./assets/images/menu.png');
    },
    create:function()
    {
        this.add.button(0, 0, 'menu',this.startGame,this);
    },
    startGame: function()
    {
        if(gameMode==1) this.state.start('Game');
        if(gameMode==2) this.state.start('Game2');
        if(gameMode==3) this.state.start('Gamem');
    }
};


game = new Phaser.Game(600, 450, Phaser.AUTO, 'snake-container');

game.state.add('Menu',Menu);
//game.state.add('Game', Game);
if(gameMode==1) game.state.add('Game', Game);
if(gameMode==2) game.state.add('Game2', Game2);
if(gameMode==3) game.state.add('Gamem', Gamem);

game.state.add('Game_Over', Game_Over);

game.state.start('Menu');








var Snake= function (player,skin,startPosition)
{
        this.name=player || 'player',
        this.body=[],
        this.initialBody=8,
        this.bodySkin=skin || 'snake',
        this.score=0,
        this.direction='',
        this.newdirection=null,
        this.addNew=0,
        this.scoreTextValue='',
        this.oldLastCellx=0,
        this.oldLastCelly=0;
        this.startPosition=startPosition || 1;
        this.alive=true;

        switch (this.startPosition)
        {
            case 1:
                this.startPositiony=90;
                this.direction= 'right';
                break;
            case 2:
                this.startPositiony=180;
                this.direction= 'right';
                break;
            case 3:
                this.startPositiony=270;
                this.direction= 'right';
                break;
            case 4:
                this.startPositiony=360;
                this.direction= 'right';
                break;
            case 5:
                this.startPositiony=135;
                this.direction= 'left';
                break;
            case 6:
                this.startPositiony=225;
                this.direction= 'left';
                break;
            case 7:
                this.startPositiony=335;
                this.direction= 'left';
                break;
            case 8:
                this.startPositiony=405;
                this.direction= 'left';
                break;
        }

    this.getFirstCell = function()
    {
        return this.body[this.body.length - 1];
    }
    this.getLastCell =function ()
    {
        return this.body.shift();
    }

    this.move = function()
    {
        if(this.alive)
        {
            lastCell = this.getLastCell(),
                firstCell = this.getFirstCell();
            this.oldLastCellx=lastCell.x,
                this.oldLastCelly=lastCell.y;
            if(this.direction == 'right'){

                lastCell.x = firstCell.x + 15;
                lastCell.y = firstCell.y;
            }
            else if(this.direction == 'left'){
                lastCell.x = firstCell.x - 15;
                lastCell.y = firstCell.y;
            }
            else if(this.direction== 'up'){
                lastCell.x = firstCell.x;
                lastCell.y = firstCell.y - 15;
            }
            else if(this.direction == 'down'){
                lastCell.x = firstCell.x;
                lastCell.y = firstCell.y + 15;
            }

            if(this.newdirection){
                this.direction = this.newdirection;
                this.newdirection = null;
            }

            if(this.direction == 'right'){

                lastCell.x = firstCell.x + 15;
                lastCell.y = firstCell.y;
            }
            else if(this.direction == 'left'){
                lastCell.x = firstCell.x - 15;
                lastCell.y = firstCell.y;
            }
            else if(this.direction == 'up'){
                lastCell.x = firstCell.x;
                lastCell.y = firstCell.y - 15;
            }
            else if(this.direction == 'down'){
                lastCell.x = firstCell.x;
                lastCell.y = firstCell.y + 15;
            }


            // Place the last cell in the front of the stack.
            // Mark it the first cell.

            this.body.push(lastCell);
            firstCell = lastCell;
        }


    }

    this.generateBody = function ()
    {
        for(var i = 0; i < this.initialBody; i++){
            if(this.direction=='right')
            {
                this.body[i] = game.add.sprite(15+i*squareSize, this.startPositiony, this.bodySkin);
            }
            else
            {
                this.body[i] = game.add.sprite(570-i*squareSize, this.startPositiony, this.bodySkin);
            }
        }
    }
    this.generateScore = function (styleKey,styleValue,x,y)
    {
        game.add.text(x, y, this.name+': ' , styleKey);
        this.scoreTextValue = game.add.text(x+70, y-2, this.score.toString(), styleValue);
    }

    this.grow = function ()
    {
        if(this.addNew>0){
            this.body.unshift(game.add.sprite(this.oldLastCellx, this.oldLastCelly, this.bodySkin));
            this.addNew--;
        }
    }
    this.snakeDie = function ()
    {

        var length=this.body.length;
        for(var i = 0; i < length; i++){

            //if(this.body[i].alive) alert(this.body[i].alive);
            this.body[i].loadTexture('boom', 0);

            var cellkill=this.body[i].animations.add('explode');
            cellkill.killOnComplete = true;
            this.body[i].animations.play('explode', 7, false);
            cellkill.onComplete.add(function() {
                this.kill();

            },this.body[i]);
        }
        this.alive=false;
    }
    this.generateBody();

}

var Fruit = function (name, value)
{
    this.name = name || 'apple';
    this.value = value || 1;
    this.posx =  0,
        this.posy  = 0;
    this.fruitInstance;

    // Add a new apple.
    this.createFruit = function()
    {
        this.posx =  Math.floor(Math.random() * 40 ) * squareSize,
            this.posy  = Math.floor(Math.random() * 30 ) * squareSize;
        this.fruitInstance = game.add.sprite(this.posx, this.posy, this.name);
    }
    this.createFruit();
    this.destroyFruit = function ()
    {
        this.fruitInstance.destroy();
    }
}

function snakeCollision(snake,snake2) {
    if(snake.alive && snake2.alive)
    {
        head=snake.getFirstCell();
        // Check if the head of the snake overlaps with any part of the snake.
        for(var i = 0; i < snake2.body.length - 1; i++){
            if(head.x == snake2.body[i].x && head.y == snake2.body[i].y){

                //game.state.start('Game_Over');
                snake.snakeDie();
            }
        }
    }
}
function fruitCollision(snake,fruit) {
    if(snake.alive) {
        // Check if any part of the snake is overlapping the apple.
        // This is needed if the apple spawns inside of the snake.
        for (var i = 0; i < snake.body.length; i++) {
            if (snake.body[i].x == fruit.fruitInstance.x && snake.body[i].y == fruit.fruitInstance.y) {

                // Next time the snake moves, a new block will be added to its length.
                snake.addNew = snake.addNew + fruit.value;

                // Destroy the old apple.
                fruit.destroyFruit();
                fruit.createFruit();
                // Make a new one.

                // Increase score.
                if(fruit.name=='apple') snake.score=snake.score+3;
                else if(fruit.name=='orange') snake.score=snake.score+2;
                else if(fruit.name=='banana') snake.score++;

                // Refresh scoreboard.

                snake.scoreTextValue.text = snake.score.toString();

            }
        }
    }
}
function wallCollision(snake) {
    if(snake.alive) {
        head = snake.getFirstCell();
        // Check if the head of the snake is in the boundaries of the game field.

        if (head.x >= 600 || head.x < 0 || head.y >= 450 || head.y < 0) {
            snake.snakeDie();
        }
    }
}
function isEmpty(obj) {

    // null and undefined are "empty"
    if (obj == null) return true;

    // Assume if it has a length property with a non-zero value
    // that that property is correct.
    if (obj.length > 0)    return false;
    if (obj.length === 0)  return true;

    // Otherwise, does it have any properties of its own?
    // Note that this doesn't handle
    // toString and valueOf enumeration bugs in IE < 9
    for (var key in obj) {
        if (hasOwnProperty.call(obj, key)) return false;
    }

    return true;
}
